<# 
.SYNOPSIS
  Windows 10/11 Optimizer – SafePlus (SSD) [One-Shot]
  Limpieza/optimización ampliada, segura y reversible.

.INCLUYE (modo seguro):
  • Mega-limpieza: TEMP de todos los usuarios, caches UWP/WebView2/Apps, WU/DO, WER/dumps,
    logs viejos (CBS/DISM/MoSetup/Panther/WMI/BITS), miniaturas/iconos, FontCache, Prefetch *.pf
  • Navegadores: Chrome/Edge/Firefox/Brave/Opera (caches)
  • Inicio: deshabilita mediante StartupApproved y exporta/borra Run/RunOnce; accesos directos a cuarentena
  • Servicios: SysMain & DiagTrack → Disabled; WSearch → Manual; Xbox → Manual; RemoteRegistry → Disabled
  • Red segura: LLMNR off, Delivery Optimization HTTP only, winsock/IP reset
  • Edge policies: sin segundo plano/startup boost/primer inicio/telemetría básica
  • SSD: Hibernación OFF, ReTRIM de C:
  • Tareas programadas típicas (CEIP/Xbl/RetailDemo) deshabilitadas
  • SFC/DISM verificación
  • Punto de restauración (si está habilitado)

  Logs en:   C:\ProgramData\SafePlus\Logs\SafePlus-<fecha>.log
  Quarantine:C:\ProgramData\SafePlus\Quarantine-<fecha>\
#>

#========================
# PREPARACIÓN & VARIABLES
#========================
[CmdletBinding()] param(
  [int]$LogRetentionDays = 7,
  [switch]$Aggressive    # limpia Windows.old/$WINDOWS.~BT y Package Cache antiguo
)

# Admin check
$principal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
if (-not $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
  Write-Host "[!] Ejecuta PowerShell como ADMINISTRADOR." -ForegroundColor Red
  return
}

# Silencio total de prompts/progreso
$ProgressPreference = 'SilentlyContinue'
$global:ConfirmPreference = 'None'
$PSDefaultParameterValues['*:Confirm'] = $false
$PSDefaultParameterValues['*:ErrorAction'] = 'SilentlyContinue'

# Rutas seguras (NO se limpian)
$Stamp      = Get-Date -Format 'yyyyMMdd-HHmmss'
$BaseRoot   = "C:\ProgramData\SafePlus"
$LogRoot    = Join-Path $BaseRoot "Logs"
$SessionLog = Join-Path $LogRoot  ("SafePlus-{0}.log" -f $Stamp)
$Quarantine = Join-Path $BaseRoot ("Quarantine-{0}" -f $Stamp)

#========================
# UTILIDADES
#========================
function Ensure-Dir([string]$p){
  if (-not (Test-Path $p)) { New-Item -Path $p -ItemType Directory -Force | Out-Null }
}
Ensure-Dir $BaseRoot; Ensure-Dir $LogRoot; Ensure-Dir $Quarantine

function Write-Log{
  param([string]$Message,[ValidateSet('INFO','WARN','ERROR','SUCCESS','TITLE','STEP')]$Level='INFO')
  try { Ensure-Dir $LogRoot } catch {}
  $ts = Get-Date -Format "HH:mm:ss"
  $color = @{ INFO='White'; WARN='Yellow'; ERROR='Red'; SUCCESS='Green'; TITLE='Cyan'; STEP='Gray' }[$Level]
  $line = "[{0}] [{1}] - {2}" -f $ts,$Level,$Message
  Write-Host $line -ForegroundColor $color
  try { Add-Content -Path $SessionLog -Value $line -Encoding UTF8 } catch {}
}

function Try-Do([scriptblock]$sb){
  try { & $sb } catch { Write-Log ('Excepción: {0}' -f $_.Exception.Message) 'WARN' }
}

function BytesToHuman([Int64]$b){
  if($b -ge 1GB){ return ('{0:N2} GB' -f ($b/1GB)) }
  elseif($b -ge 1MB){ return ('{0:N2} MB' -f ($b/1MB)) }
  elseif($b -ge 1KB){ return ('{0:N2} KB' -f ($b/1KB)) }
  else{ return ('{0} B' -f $b) }
}

function Backup-Registry([string]$KeyPath){
  # Exporta a .reg si existe
  $regPath = $KeyPath -replace '^HKCU:', 'HKEY_CURRENT_USER' -replace '^HKLM:', 'HKEY_LOCAL_MACHINE'
  if(-not (Test-Path $regPath)){ Write-Log ('Sin backup, no existe: {0}' -f $regPath) 'INFO'; return }
  $safeName = ($KeyPath -replace '[:\\\/]','_')
  $backupFile = Join-Path $Quarantine ("RegBackup-{0}.reg" -f $safeName)
  Try-Do { & reg.exe export "$regPath" "$backupFile" /y | Out-Null; Write-Log ('Backup reg -> {0}' -f $backupFile) 'INFO' }
}

function Set-RegistryValue([string]$Path,[string]$Name,$Value,[Microsoft.Win32.RegistryValueKind]$Type){
  Try-Do {
    if(-not (Test-Path $Path)){ New-Item -Path $Path -Force | Out-Null }
    New-ItemProperty -Path $Path -Name $Name -Value $Value -PropertyType $Type -Force | Out-Null
    Write-Log ('Registro: {0}\{1} = {2}' -f $Path,$Name,$Value) 'SUCCESS'
  }
}

# Borrado con control de directorios/archivos, sin prompts, y protegiendo rutas propias
function Remove-PathContents {
  param(
    [Parameter(Mandatory)][string]$Path,
    [string[]]$Include = @('*'),
    [string[]]$Exclude = @(),
    [switch]$IncludeDirs  # si true, borra directorios también (con -Recurse)
  )
  if(-not (Test-Path $Path)){ return 0L }
  $freed = 0L

  # PROTECCIÓN de nuestros directorios
  $protect = @($BaseRoot.TrimEnd('\'), $LogRoot.TrimEnd('\'), $Quarantine.TrimEnd('\'))

  # Recolectar items
  $items = @()
  if ($IncludeDirs) {
    # Directorios + archivos
    $items = Get-ChildItem -LiteralPath $Path -Recurse -Force -ErrorAction SilentlyContinue
  } else {
    # Solo archivos
    $items = Get-ChildItem -LiteralPath $Path -Recurse -Force -File -ErrorAction SilentlyContinue
  }

  foreach($it in $items){
    $full = $it.FullName.TrimEnd('\')
    # No tocar lo nuestro
    if ($protect | Where-Object { $full -like ("{0}*" -f $_) }) { continue }
    # Filtro Include/Exclude por nombre
    $name = $it.Name
    $matchInclude = $false
    foreach($pat in $Include){ if ($name -like $pat) { $matchInclude = $true; break } }
    if (-not $matchInclude) { continue }
    foreach($ex in $Exclude){ if ($name -like $ex) { $matchInclude = $false; break } }
    if (-not $matchInclude) { continue }

    # Sumar tamaño (archivos o tamaño total si es directorio)
    try {
      if ($it.PSIsContainer) {
        $size = (Get-ChildItem -LiteralPath $full -Recurse -Force -File -EA SilentlyContinue | Measure-Object -Sum Length).Sum
        if ($null -eq $size) { $size = 0 }
        $freed += [int64]$size
        Remove-Item -LiteralPath $full -Recurse -Force -ErrorAction SilentlyContinue -Confirm:$false
      } else {
        $freed += [int64]$it.Length
        Remove-Item -LiteralPath $full -Force -ErrorAction SilentlyContinue -Confirm:$false
      }
    } catch {}
  }
  return $freed
}

# Borrado por antigüedad (solo archivos)
function Remove-OldFiles {
  param(
    [Parameter(Mandatory)][string]$Path,
    [int]$OlderThanDays = 7,
    [string[]]$Patterns = @('*')
  )
  if (-not (Test-Path $Path)) { return 0L }
  $cut = (Get-Date).AddDays(-[math]::Abs($OlderThanDays))
  $total = 0L
  try {
    Get-ChildItem -LiteralPath $Path -Recurse -Force -File -ErrorAction SilentlyContinue |
      Where-Object { $_.LastWriteTime -lt $cut } |
      ForEach-Object {
        $fn = $_.Name
        $ok = $false
        foreach ($pat in $Patterns) { if ($fn -like $pat) { $ok = $true; break } }
        if (-not $ok) { return }
        # No tocar lo nuestro
        $full = $_.FullName
        if ($full -like ("{0}*" -f $BaseRoot)) { return }
        $total += [int64]$_.Length
        Remove-Item -LiteralPath $full -Force -ErrorAction SilentlyContinue -Confirm:$false
      }
  } catch {}
  return $total
}

#========================
# MÓDULOS
#========================
function Start-Diagnostics {
  Write-Log "MÓDULO: Diagnóstico & Punto de restauración" 'TITLE'
  Try-Do {
    $os = Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion, OsArchitecture
    Write-Log ('SO: {0} v{1} ({2})' -f $os.WindowsProductName,$os.WindowsVersion,$os.OsArchitecture) 'INFO'
  }
  Try-Do {
    $disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'"
    Write-Log ('C: {0} libres de {1} GB' -f ([math]::Round($disk.FreeSpace/1GB,2)),[math]::Round($disk.Size/1GB,2)) 'INFO'
  }
  Try-Do {
    Checkpoint-Computer -Description ("SafePlus-{0}" -f $Stamp) -ErrorAction SilentlyContinue
    Write-Log "Punto de restauración solicitado (si está habilitado)." 'INFO'
  }
}

function Invoke-MegaCleanup {
  Write-Log "MÓDULO: Mega Limpieza (Safe, SSD-friendly)" 'TITLE'
  $before = (Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'").FreeSpace
  $freed = 0L

  Write-Log "Protegidos: $BaseRoot | $LogRoot | $Quarantine" 'STEP'

  # 1) TEMP por usuario + UWP caches + Apps comunes + WebView2 + OneDrive logs
  Write-Log "Usuarios: TEMP/INetCache/CrashDumps + UWP(LocalCache/TempState/AC) + Teams/Slack/Discord/Spotify + WebView2" 'STEP'
  Try-Do {
    $userRoots = Get-ChildItem 'C:\Users' -Directory -ErrorAction SilentlyContinue |
                 Where-Object { $_.Name -notin @('Default','Default User','Public','All Users') }
    foreach ($u in $userRoots) {
      $usr = $u.FullName
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Temp" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Microsoft\Windows\INetCache" -f $usr) -IncludeDirs
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\CrashDumps" -f $usr)

      $pkgRoot = ("{0}\AppData\Local\Packages" -f $usr)
      if (Test-Path $pkgRoot) {
        Get-ChildItem $pkgRoot -Directory -EA SilentlyContinue | ForEach-Object {
          $freed += Remove-PathContents -Path ("{0}\LocalCache" -f $_.FullName)  -IncludeDirs
          $freed += Remove-PathContents -Path ("{0}\TempState" -f $_.FullName)   -IncludeDirs
          $freed += Remove-PathContents -Path ("{0}\AC" -f $_.FullName)          -IncludeDirs
        }
      }

      # Teams / Slack / Discord / Spotify
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Microsoft\Teams\Cache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Microsoft\Teams\Code Cache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Microsoft\Teams\GPUCache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Microsoft\Teams\Service Worker\CacheStorage" -f $usr) -IncludeDirs

      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Slack\Cache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Slack\Code Cache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Slack\GPUCache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Slack\Service Worker\CacheStorage" -f $usr) -IncludeDirs

      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Spotify\Storage" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Roaming\Spotify\Data" -f $usr)

      # WebView2
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Microsoft\EdgeWebView\Application\*\User Data\*\Cache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Microsoft\EdgeWebView\Application\*\User Data\*\Code Cache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Microsoft\EdgeWebView\Application\*\User Data\*\GPUCache" -f $usr)
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Microsoft\EdgeWebView\Application\*\User Data\*\Service Worker\CacheStorage" -f $usr) -IncludeDirs

      # OneDrive logs
      $freed += Remove-PathContents -Path ("{0}\AppData\Local\Microsoft\OneDrive\logs" -f $usr)
    }
  }

  # 2) Prefetch *.pf (mantiene Layout.ini) + GPU caches globales
  $freed += Remove-PathContents -Path "$env:SystemRoot\Prefetch" -Include @('*.pf') -Exclude @('Layout.ini')
  $freed += Remove-PathContents -Path "$env:LOCALAPPDATA\NVIDIA\GLCache" -IncludeDirs
  $freed += Remove-PathContents -Path "$env:LOCALAPPDATA\AMD\DxCache"   -IncludeDirs
  $freed += Remove-PathContents -Path "$env:LOCALAPPDATA\D3DSCache"     -IncludeDirs

  # 3) Windows Update / Delivery Optimization
  Write-Log "Windows Update cache + Delivery Optimization" 'STEP'
  $freed += Remove-PathContents -Path "$env:SystemRoot\SoftwareDistribution\Download" -IncludeDirs
  Try-Do { Stop-Service -Name DoSvc -Force -EA SilentlyContinue }
  $freed += Remove-PathContents -Path "$env:ProgramData\Microsoft\Windows\DeliveryOptimization\Cache" -IncludeDirs
  Try-Do { Start-Service -Name DoSvc -EA SilentlyContinue }

  # 4) WER y dumps
  $freed += Remove-PathContents -Path "$env:ProgramData\Microsoft\Windows\WER\ReportQueue"   -IncludeDirs
  $freed += Remove-PathContents -Path "$env:ProgramData\Microsoft\Windows\WER\ReportArchive" -IncludeDirs
  $freed += Remove-PathContents -Path "$env:SystemRoot\Minidump" -Include @('*.dmp')
  if (Test-Path "$env:SystemRoot\MEMORY.DMP") {
    Try-Do {
      $f = Get-Item "$env:SystemRoot\MEMORY.DMP" -EA SilentlyContinue
      if ($f) {
        $freed += [int64]$f.Length
        Remove-Item -LiteralPath $f.FullName -Force -EA SilentlyContinue -Confirm:$false
      }
    }
  }

  # 5) Logs viejos del sistema
  Write-Log ("Purgando logs del sistema >= {0} días" -f $LogRetentionDays) 'STEP'
  $freed += Remove-OldFiles -Path "$env:SystemRoot\Logs\CBS"     -OlderThanDays $LogRetentionDays -Patterns @('*.log','*.cab')
  $freed += Remove-OldFiles -Path "$env:SystemRoot\Logs\DISM"    -OlderThanDays $LogRetentionDays -Patterns @('*.log','*.cab')
  $freed += Remove-OldFiles -Path "$env:SystemRoot\Logs\MoSetup" -OlderThanDays $LogRetentionDays
  $freed += Remove-OldFiles -Path "$env:SystemRoot\Panther"      -OlderThanDays $LogRetentionDays
  $freed += Remove-OldFiles -Path "$env:SystemRoot\System32\LogFiles\WMI"  -OlderThanDays $LogRetentionDays
  $freed += Remove-OldFiles -Path "$env:SystemRoot\System32\LogFiles\BITS" -OlderThanDays $LogRetentionDays

  # 6) Defender logs (no definiciones)
  $freed += Remove-OldFiles -Path "$env:ProgramData\Microsoft\Windows Defender\Support" -OlderThanDays $LogRetentionDays -Patterns @('*.log','*.etl')

  # 7) Miniaturas/Iconos + FontCache
  Try-Do {
    Stop-Process -Name explorer -Force -EA SilentlyContinue
    $freed += Remove-PathContents -Path "$env:LOCALAPPDATA\Microsoft\Windows\Explorer" -Include @('thumbcache_*.db')
    $freed += Remove-PathContents -Path "$env:LOCALAPPDATA" -Include @('IconCache.db')
    Start-Process explorer.exe
  }
  Try-Do {
    Stop-Service -Name "FontCache" -Force -EA SilentlyContinue
    $freed += Remove-PathContents -Path "$env:SystemRoot\ServiceProfiles\LocalService\AppData\Local" -Include @('FontCache*')
    $freed += Remove-PathContents -Path "$env:LOCALAPPDATA" -Include @('FontCache*')
    Start-Service -Name "FontCache" -EA SilentlyContinue
  }

  # 8) .NET Temporary ASP.NET Files
  $freed += Remove-PathContents -Path "$env:SystemRoot\Microsoft.NET\Framework*\v*\Temporary ASP.NET Files"    -IncludeDirs
  $freed += Remove-PathContents -Path "$env:SystemRoot\Microsoft.NET\Framework64*\v*\Temporary ASP.NET Files"  -IncludeDirs

  # 9) Downloaded Program Files
  $freed += Remove-PathContents -Path "$env:SystemRoot\Downloaded Program Files" -IncludeDirs

  # 10) Papelera + DNS
  Try-Do { Clear-RecycleBin -Force }
  Try-Do { ipconfig /flushdns | Out-Null }

  # 11) OPCIONAL AGRESIVO
  if ($Aggressive.IsPresent) {
    Write-Log "AGRESIVO: Windows.old / \$WINDOWS.~BT / \$WINDOWS.~WS y Package Cache antiguo…" 'WARN'
    foreach ($cand in @("C:\Windows.old","C:\$WINDOWS.~BT","C:\$WINDOWS.~WS")) {
      if (Test-Path $cand) {
        Try-Do {
          $sz = (Get-ChildItem -LiteralPath $cand -Recurse -Force -File -EA SilentlyContinue | Measure-Object -Sum Length).Sum
          if ($null -eq $sz) { $sz = 0 }
          Remove-Item -LiteralPath $cand -Recurse -Force -EA SilentlyContinue -Confirm:$false
          $freed += [int64]$sz
        }
      }
    }
    $vsCache = "C:\ProgramData\Package Cache"
    if (Test-Path $vsCache) {
      $freed += Remove-OldFiles -Path $vsCache -OlderThanDays $LogRetentionDays
    }
  }

  $after = (Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'").FreeSpace
  $delta = $after - $before
  if ($delta -lt 0) { $delta = $freed }
  Write-Log ("MEGA Limpieza: {0}" -f (BytesToHuman $delta)) 'SUCCESS'
}

function Invoke-BrowserCleanup {
  Write-Log "MÓDULO: Navegadores (caches)" 'TITLE'
  $targets = @(
    @{Name="Chrome";  Paths=@("$env:LOCALAPPDATA\Google\Chrome\User Data\*\Cache","$env:LOCALAPPDATA\Google\Chrome\User Data\*\Code Cache","$env:LOCALAPPDATA\Google\Chrome\User Data\*\GPUCache","$env:LOCALAPPDATA\Google\Chrome\User Data\*\Service Worker\CacheStorage")},
    @{Name="Edge";    Paths=@("$env:LOCALAPPDATA\Microsoft\Edge\User Data\*\Cache","$env:LOCALAPPDATA\Microsoft\Edge\User Data\*\Code Cache","$env:LOCALAPPDATA\Microsoft\Edge\User Data\*\GPUCache","$env:LOCALAPPDATA\Microsoft\Edge\User Data\*\Service Worker\CacheStorage")},
    @{Name="Firefox"; Paths=@("$env:APPDATA\Mozilla\Firefox\Profiles\*\cache2","$env:LOCALAPPDATA\Mozilla\Firefox\Profiles\*\cache2")},
    @{Name="Brave";   Paths=@("$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data\*\Cache","$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data\*\Code Cache","$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data\*\GPUCache")},
    @{Name="Opera";   Paths=@("$env:APPDATA\Opera Software\Opera GX Stable\Cache","$env:APPDATA\Opera Software\Opera Stable\Cache")}
  )
  foreach($t in $targets){
    foreach($p in $t.Paths){ Remove-PathContents -Path $p -IncludeDirs | Out-Null }
    Write-Log ("Caché de {0} limpia." -f $t.Name) 'SUCCESS'
  }
}

function Invoke-StartupSafe {
  Write-Log "MÓDULO: Inicio (deshabilitado seguro + cuarentena)" 'TITLE'
  $BIN_DISABLED = [byte[]](0x02,0,0,0,0,0,0,0)
  $SA_KEYS = @(
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run32',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\StartupFolder',
    'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run',
    'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run32'
  )
  foreach($k in $SA_KEYS){ if(-not (Test-Path $k)){ New-Item -Path $k -Force | Out-Null } }

  $RUN_KEYS = @(
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\Run',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    'HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run',
    'HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce'
  )
  $STARTUP_FOLDERS = @(
    [Environment]::GetFolderPath('Startup'),
    "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\StartUp"
  )
  $ProtectedRegex = '(?i)(\\Microsoft\\|Windows\s*Defender|SecurityHealth|Windows\s*Security|OneDrive)'

  $candidates = New-Object System.Collections.Generic.List[object]

  foreach($key in $RUN_KEYS){
    if(-not (Test-Path $key)){ continue }
    Backup-Registry $key
    Try-Do {
      $item = Get-Item $key -EA SilentlyContinue
      foreach($name in ($item.Property | Where-Object { $_ -and $_ -ne '(default)' })){
        $val = (Get-ItemProperty -Path $key -Name $name -EA SilentlyContinue).$name
        if([string]::IsNullOrWhiteSpace([string]$val)){ continue }
        if(([string]$val) -match $ProtectedRegex){ continue }
        $candidates.Add([pscustomobject]@{Kind='Reg'; Key=$key; Name=$name; Value=[string]$val}) | Out-Null
      }
    }
  }

  foreach($dir in $STARTUP_FOLDERS){
    if(-not (Test-Path $dir)){ continue }
    Try-Do {
      Get-ChildItem -LiteralPath $dir -File -EA SilentlyContinue | ForEach-Object {
        if($_.FullName -match $ProtectedRegex){ return }
        $candidates.Add([pscustomobject]@{Kind='File'; Path=$_.FullName; Name=$_.Name}) | Out-Null
      }
    }
  }

  # Marcar Disabled en StartupApproved por nombre
  function _SA_DisableName([string]$n){
    foreach($k in $SA_KEYS){
      Try-Do { New-ItemProperty -Path $k -Name $n -Value $BIN_DISABLED -PropertyType Binary -Force | Out-Null }
    }
  }
  foreach($it in $candidates){ _SA_DisableName $it.Name }

  # Eliminar Run/RunOnce y mover accesos
  $removed=0; $moved=0
  foreach($it in $candidates){
    if($it.Kind -eq 'Reg'){
      Try-Do { Remove-ItemProperty -Path $it.Key -Name $it.Name -Force -EA Stop -Confirm:$false; $removed++ }
    } else {
      if(Test-Path $it.Path){
        $dest = Join-Path $Quarantine ([IO.Path]::GetFileName($it.Path))
        Try-Do { Move-Item -LiteralPath $it.Path -Destination $dest -Force -EA Stop; $moved++ }
      }
    }
  }
  Write-Log ("Inicio deshabilitado. Reg eliminados: {0} | Accesos movidos: {1}" -f $removed,$moved) 'SUCCESS'
}

function Invoke-ServicesSafe {
  Write-Log "MÓDULO: Servicios (perfil seguro)" 'TITLE'
  foreach($s in @('SysMain','DiagTrack')){
    Try-Do { Stop-Service -Name $s -Force -EA SilentlyContinue }
    Try-Do { Set-Service -Name $s -StartupType Disabled }
  }
  Try-Do { Set-Service -Name 'WSearch' -StartupType Manual }
  foreach($sx in @('XblAuthManager','XblGameSave','XboxGipSvc','XboxNetApiSvc')){
    Try-Do { Set-Service -Name $sx -StartupType Manual }
  }
  Try-Do { Set-Service -Name 'RemoteRegistry' -StartupType Disabled }
  Write-Log "Servicios ajustados (seguros)." 'SUCCESS'
}

function Invoke-NetworkSafe {
  Write-Log "MÓDULO: Red segura & Delivery Optimization" 'TITLE'
  $doPath="HKLM:\SOFTWARE\Policies\Microsoft\Windows\DeliveryOptimization"
  Backup-Registry $doPath
  Set-RegistryValue $doPath "DODownloadMode" 0 ([Microsoft.Win32.RegistryValueKind]::DWord)  # HTTP only

  $dnsCli="HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient"
  Backup-Registry $dnsCli
  Set-RegistryValue $dnsCli "EnableMulticast" 0 ([Microsoft.Win32.RegistryValueKind]::DWord)  # LLMNR off

  Try-Do { netsh winsock reset | Out-Null }
  Try-Do { netsh int ip reset | Out-Null }
  Write-Log "Red endurecida y DO configurado." 'SUCCESS'
}

function Invoke-EdgePolicies {
  Write-Log "MÓDULO: Microsoft Edge (políticas)" 'TITLE'
  $hkcu="HKCU:\Software\Microsoft\Edge"
  $hklm="HKLM:\SOFTWARE\Policies\Microsoft\Edge"
  Backup-Registry $hkcu; Backup-Registry $hklm
  Set-RegistryValue $hkcu "StartupBoostEnabled"   0 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Set-RegistryValue $hkcu "BackgroundModeEnabled" 0 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Set-RegistryValue $hklm "StartupBoostEnabled"   0 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Set-RegistryValue $hklm "BackgroundModeEnabled" 0 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Set-RegistryValue $hklm "MetricsReportingEnabled" 0 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Set-RegistryValue $hklm "HideFirstRunExperience"  1 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Set-RegistryValue $hklm "NewTabPagePrerenderEnabled" 0 ([Microsoft.Win32.RegistryValueKind]::DWord)
  Write-Log "Edge ajustado." 'SUCCESS'
}

function Invoke-SSDOptimize {
  Write-Log "MÓDULO: SSD (Hibernación OFF + ReTRIM)" 'TITLE'
  Try-Do { powercfg /h off | Out-Null }
  Try-Do { Optimize-Volume -DriveLetter C -ReTrim -Verbose | Out-Null }
  Try-Do { dism.exe /Online /Cleanup-Image /StartComponentCleanup | Out-Null } # seguro (no /ResetBase)
  Write-Log "Hibernación deshabilitada, TRIM ejecutado y WinSxS limpiado." 'SUCCESS'
}

function Invoke-ScheduledTasksSafe {
  Write-Log "MÓDULO: Tareas programadas (CEIP/Xbl/RetailDemo)" 'TITLE'
  $tasks = @(
    "\Microsoft\Windows\Customer Experience Improvement Program\Consolidator",
    "\Microsoft\Windows\Customer Experience Improvement Program\UsbCeip",
    "\Microsoft\Windows\Customer Experience Improvement Program\KernelCeipTask",
    "\Microsoft\XblGameSave\XblGameSaveTask",
    "\Microsoft\XblGameSave\XblGameSaveTaskLogon",
    "\Microsoft\Windows\RetailDemo\CleanupOfflineContent"
  )
  foreach($t in $tasks){
    Try-Do {
      $taskPath = (Split-Path $t -Parent) + "\"
      $taskName = Split-Path $t -Leaf
      Disable-ScheduledTask -TaskPath $taskPath -TaskName $taskName -EA SilentlyContinue | Out-Null
      schtasks /change /TN $t /DISABLE | Out-Null
    }
  }
  Write-Log "Tareas típicas deshabilitadas." 'SUCCESS'
}

function Run-IntegrityChecks {
  Write-Log "MÓDULO: Integridad (SFC/DISM) – puede tardar" 'TITLE'
  Try-Do { sfc.exe /scannow | Out-Null }
  Try-Do { dism.exe /Online /Cleanup-Image /RestoreHealth | Out-Null }
  Write-Log "Comprobación de sistema finalizada." 'SUCCESS'
}

#========================
# EJECUCIÓN
#========================
$start = Get-Date
Write-Log "SafePlus (SSD) iniciando…" 'TITLE'

Start-Diagnostics
Invoke-MegaCleanup
Invoke-BrowserCleanup
Invoke-StartupSafe
Invoke-ServicesSafe
Invoke-NetworkSafe
Invoke-EdgePolicies
Invoke-SSDOptimize
Invoke-ScheduledTasksSafe
Run-IntegrityChecks

$end = Get-Date
$dur = New-TimeSpan -Start $start -End $end
Write-Log ('FIN. Duración: {0} | Log: {1} | Cuarentena: {2}' -f $dur,$SessionLog,$Quarantine) 'TITLE'
Write-Host "Recomendado: reiniciar el equipo para aplicar todo." -ForegroundColor Green
