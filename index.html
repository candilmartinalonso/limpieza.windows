<#
.SYNOPSIS
    Script de Optimización "Ultimate Edition" para Windows 11 (v5.3 - Corrección Final).
    Diseñado para ser copiado y pegado directamente en una consola de PowerShell (Administrador).
    Esta versión omite la creación del punto de restauración por defecto y corrige el fallo de cierre.

.DESCRIPTION
    ADVERTENCIA: Este script realiza cambios profundos en el sistema. Al no crear un punto de
    restauración, los cambios son más difíciles de revertir. Úsalo bajo tu propia responsabilidad.

    MODO DE USO:
    1. Abre PowerShell con "Ejecutar como administrador".
    2. Copia TODO este código.
    3. Pégalo en la ventana de PowerShell y presiona Enter.
#>

[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact='High')]
param(
    [switch]$DryRun,
    [switch]$Interactive,
    [switch]$IncludeOptionalCleanup,
    [switch]$NoRestorePoint,
    [switch]$KeepOneDrive,
    [switch]$KeepGameDVR,
    [switch]$KeepStandardPowerPlan,
    [switch]$KeepModernMenu,
    [switch]$SkipTelemetryBlock,
    [ValidateSet('Cloudflare', 'Google')]
    [string]$SetDNS,
    [ValidateSet('Diagnostics', 'Cleanup', 'OptionalCleanup', 'Debloat', 'Services', 'SSD', 'SystemTweaks', 'Privacy', 'UITweaks', 'NetworkTweaks', 'AppUpdater', 'Integrity')]
    [string[]]$Skip,
    [ValidateSet('Diagnostics', 'Cleanup', 'OptionalCleanup', 'Debloat', 'Services', 'SSD', 'SystemTweaks', 'Privacy', 'UITweaks', 'NetworkTweaks', 'AppUpdater', 'Integrity')]
    [string[]]$Only,
    [string[]]$KeepApps,
    [string[]]$RemoveApps,
    [string]$JsonReport
)

#region VARIABLES GLOBALES Y CONFIGURACIÓN INICIAL

$Global:IsDryRun = $DryRun.IsPresent
$PSDefaultParameterValues['*:Confirm'] = if ($IsDryRun -or $Interactive) { $true } else { $false }

$Global:LogPath = "C:\Logs\Win11-Cleanup"
if (-not (Test-Path -Path $Global:LogPath)) { try { New-Item -Path $Global:LogPath -ItemType Directory -Force | Out-Null } catch { Write-Error "No se pudo crear el directorio de logs."; exit 1 } }
$Global:LogFile = Join-Path $Global:LogPath "Win11-Cleanup-$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss').log"
$Global:StartTime = Get-Date

$Global:Report = [PSCustomObject]@{
    ExecutionDate   = $Global:StartTime
    ExecutionMode   = if ($IsDryRun) { 'DryRun' } elseif ($Interactive) { 'Interactive' } else { 'GodMode' }
    Parameters      = $PSBoundParameters
    SpaceFreedBytes = 0
    AppsRemoved     = [System.Collections.ArrayList]@()
    AppsUpdated     = [System.Collections.ArrayList]@()
    ServicesChanged = [System.Collections.ArrayList]@()
    TasksChanged    = [System.Collections.ArrayList]@()
    RegistryChanges = [System.Collections.ArrayList]@()
    RegistryBackups = [System.Collections.ArrayList]@()
    HostFileBackups = [System.Collections.ArrayList]@()
    SystemChecks    = [System.Collections.ArrayList]@()
    NetworkChanges  = [System.Collections.ArrayList]@()
    LogFile         = $Global:LogFile
}

$Global:DefaultAppsToRemove = @(
    'Microsoft.549981C3F5F10', 'Microsoft.BingNews', 'Microsoft.BingWeather', 'Microsoft.Clipchamp',
    'Microsoft.GetHelp', 'Microsoft.Getstarted', 'Microsoft.Microsoft3DViewer', 'Microsoft.MicrosoftOfficeHub',
    'Microsoft.MicrosoftSolitaireCollection', 'Microsoft.MixedReality.Portal', 'Microsoft.People',
    'Microsoft.PowerAutomateDesktop', 'Microsoft.SkypeApp', 'Microsoft.Teams', 'Microsoft.WindowsAlarms',
    'Microsoft.WindowsFeedbackHub', 'Microsoft.WindowsMaps', 'Microsoft.YourPhone', 'Microsoft.ZuneMusic',
    'Microsoft.ZuneVideo', 'MicrosoftCorporationII.MicrosoftFamily', 'MicrosoftCorporationII.QuickAssist'
)
$Global:EssentialApps = @(
    'Microsoft.WindowsStore', 'Microsoft.UI.Xaml.*', 'Microsoft.WindowsTerminal', 'Microsoft.Windows.Photos',
    'Microsoft.Paint', 'Microsoft.WindowsCalculator', 'Microsoft.WindowsCamera', 'Microsoft.ScreenSketch',
    'Microsoft.VP9VideoExtensions', 'Microsoft.WebpImageExtension', 'Microsoft.HEIFImageExtension',
    'Microsoft.VCLibs.*', 'Microsoft.NET.*', 'Microsoft.DesktopAppInstaller', 'Microsoft.SecHealthUI',
    'NVIDIA.ControlPanel', 'Intel.*', 'AMD.*'
)
$Global:TelemetryHosts = @(
    'vortex.data.microsoft.com', 'vortex-win.data.microsoft.com', 'telemetry.microsoft.com',
    'watson.telemetry.microsoft.com', 'oca.telemetry.microsoft.com', 'settings-win.data.microsoft.com',
    'telemetry.remoteapp.microsoft.com', 'telemetry.urs.microsoft.com'
)

#endregion

#region FUNCIONES AUXILIARES

function Write-Log {
    param(
        [Parameter(Mandatory)]
        [string]$Message,
        [ValidateSet('INFO','WARN','ERROR','SUCCESS','TITLE','STEP')]
        [string]$Level = 'INFO'
    )
    $timestamp = Get-Date -Format "HH:mm:ss"
    $formattedMessage = "[$timestamp] [$Level] - $Message"
    $color = @{ INFO='White'; WARN='Yellow'; ERROR='Red'; SUCCESS='Green'; TITLE='Cyan'; STEP='Gray' }
    Write-Host $formattedMessage -ForegroundColor $color[$Level]
    Add-Content -Path $Global:LogFile -Value $formattedMessage
}

function Confirm-Action {
    param(
        [Parameter(Mandatory)]
        [string]$ModuleName,
        [string]$Description
    )
    if (-not $Interactive) { return $true }
    $title = "Confirmar Ejecución: $ModuleName"
    $message = "Vas a ejecutar el módulo '$ModuleName'.`n`n$Description`n`n¿Deseas continuar?"
    $choices = @(
        (New-Object psobject -Property @{Label='&Sí';HelpMessage='Ejecuta este módulo.'}),
        (New-Object psobject -Property @{Label='&No';HelpMessage='Omite este módulo.'}),
        (New-Object psobject -Property @{Label='&Abortar';HelpMessage='Cancela la ejecución completa.'})
    )
    $decision = $host.UI.PromptForChoice($title, $message, $choices, 0)
    switch ($decision) {
        0 { return $true }
        1 { return $false }
        2 { Write-Log "Ejecución abortada por el usuario." -Level "WARN"; throw "Abortado por el usuario." }
    }
}

function New-RestorePoint {
    param(
        # **CORRECCIÓN**: Se añade el parámetro para que la función lo reconozca.
        [switch]$NoRestorePoint
    )

    # **CORRECCIÓN**: Se usa .IsPresent para verificar si el switch fue usado en la llamada.
    if ($NoRestorePoint.IsPresent) {
        Write-Log "Creación de punto de restauración omitida." -Level "WARN"
        return # Termina la función y permite que el script continúe.
    }
    
    Write-Log "Creando punto de restauración del sistema..." -Level "INFO"
    if ($PSCmdlet.ShouldProcess("Sistema Operativo", "Crear Punto de Restauración 'Antes de Optimización Win11 v5.3'")) {
        try {
            Checkpoint-Computer -Description "Antes de Optimización Win11 v5.3" -ErrorAction Stop -Confirm:$false
            Write-Log "Punto de restauración creado con éxito." -Level "SUCCESS"
        } catch {
            # **CORRECCIÓN**: Se usa 'throw' para enviar el error al bloque 'catch' principal, en lugar de 'exit'.
            throw "FALLO CRÍTICO al crear el punto de restauración."
        }
    }
}

function Backup-Registry {
    param( [Parameter(Mandatory)] [string]$KeyPath )
    $regPath = $KeyPath -replace 'HKCU:', 'HKEY_CURRENT_USER' -replace 'HKLM:', 'HKEY_LOCAL_MACHINE'
    $keyName = $KeyPath.Split('\')[-1]
    $backupFile = Join-Path $Global:LogPath "RegistryBackup-$keyName-$(Get-Date -Format 'yyyyMMddHHmmss').reg"
    if ($PSCmdlet.ShouldProcess($regPath, "Exportar clave de registro a '$backupFile'")) {
        try {
            & reg.exe export "$regPath" "$backupFile" /y
            if ($LASTEXITCODE -eq 0) {
                Write-Log "Backup del registro creado: $backupFile" -Level "SUCCESS"
                $Global:Report.RegistryBackups.Add([PSCustomObject]@{ Key=$KeyPath; File=$backupFile }) | Out-Null
            } else {
                throw "reg.exe devolvió el código de error: $LASTEXITCODE"
            }
        } catch {
            Write-Log "FALLO al crear backup del registro para '$KeyPath'. Error: $($_.Exception.Message)" -Level "ERROR"
        }
    }
}

function Set-RegistryValue {
    param(
        [Parameter(Mandatory)] [string]$Path,
        [Parameter(Mandatory)] [string]$Name,
        [Parameter(Mandatory)] $Value,
        [Parameter(Mandatory)] [Microsoft.Win32.RegistryValueKind]$Type
    )
    if ($PSCmdlet.ShouldProcess($Path, "Establecer valor de registro '$Name' a '$Value'")) {
        try {
            if (-not (Test-Path $Path)) { New-Item -Path $Path -Force | Out-Null }
            Set-ItemProperty -Path $Path -Name $Name -Value $Value -Type $Type -Force
            Write-Log "Registro modificado: $Path\\$Name = $Value" -Level "SUCCESS"
            $Global:Report.RegistryChanges.Add("Set: $Path\\$Name = $Value") | Out-Null
        } catch {
            Write-Log "FALLO al modificar el registro: $Path\\$Name" -Level "ERROR"
        }
    }
}

#endregion

#region MÓDULOS PRINCIPALES

function Start-Diagnostics {
    if (-not (Confirm-Action "Diagnóstico" "Muestra información básica del sistema como la versión de Windows y el espacio en disco.")) { return }
    Write-Log "MÓDULO: Diagnóstico del Sistema" -Level "TITLE"
    $os = Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion, OsArchitecture
    Write-Log "Sistema Operativo: $($os.WindowsProductName) (Versión $($os.WindowsVersion), Arquitectura $($os.OsArchitecture))"
    $disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'"
    Write-Log "Disco C:: $([math]::Round($disk.FreeSpace / 1GB, 2)) GB libres de $([math]::Round($disk.Size / 1GB, 2)) GB"
    $trimStatus = fsutil.exe behavior query DisableDeleteNotify
    if ($trimStatus -match "DisableDeleteNotify = 0") {
        Write-Log "Estado de TRIM para SSDs está HABILITADO (Configuración Óptima)." -Level "SUCCESS"
    } else {
        Write-Log "Estado de TRIM para SSDs está DESHABILITADO (Configuración No Óptima)." -Level "WARN"
    }
}

function Invoke-Cleanup {
    if (-not (Confirm-Action "Limpieza Profunda" "Elimina archivos temporales, cachés de sistema, logs y vacía la papelera de reciclaje.")) { return }
    Write-Log "MÓDULO: Limpieza Profunda" -Level "TITLE"
    $cleanupTargets = @{
        "Temp"      = @{ Path = @("$env:TEMP", "$env:SystemRoot\Temp"); Recurse = $true };
        "Prefetch"  = @{ Path = "$env:SystemRoot\Prefetch"; Recurse = $false; Include = "*.pf"; Exclude = "Layout.ini" };
        "WinUpdate" = @{ Path = "$env:SystemRoot\SoftwareDistribution\Download"; Recurse = $true };
        "Dumps"     = @{ Path = @("$env:LOCALAPPDATA\CrashDumps", "$env:SystemRoot\Minidump"); Include = "*.dmp" };
        "NVIDIA"    = @{ Path = "$env:LOCALAPPDATA\NVIDIA\GLCache" };
        "AMD"       = @{ Path = "$env:LOCALAPPDATA\AMD\DxCache" }
    }
    foreach ($name in $cleanupTargets.Keys) {
        $target = $cleanupTargets[$name]
        foreach ($path in [array]$target.Path) {
            if (Test-Path $path) {
                Write-Log "Limpiando '$name' en la ruta: $path" -Level "STEP"
                $files = Get-ChildItem @target -Path $path -Force -ErrorAction SilentlyContinue
                if (!$files) { continue }
                $size = ($files | Measure-Object -Property Length -Sum).Sum
                if ($PSCmdlet.ShouldProcess($path, "Limpiar ($([math]::Round($size/1MB,2)) MB)")) {
                    $files | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                    $Global:Report.SpaceFreedBytes += $size
                }
            }
        }
    }
    if ($PSCmdlet.ShouldProcess("Papelera de Reciclaje", "Vaciar")) { Clear-RecycleBin -Force -ErrorAction SilentlyContinue }
    if ($PSCmdlet.ShouldProcess("Caché de la Tienda de Windows", "Resetear con wsreset.exe")) { & wsreset.exe -s | Out-Null }
    if ($PSCmdlet.ShouldProcess("Almacén de Componentes de Windows", "Limpiar con DISM")) { & dism.exe /Online /Cleanup-Image /StartComponentCleanup | Out-Null }
    if ($PSCmdlet.ShouldProcess("Caché de Iconos", "Reconstruir")) {
        $iconCachePath = "$env:LOCALAPPDATA\IconCache.db"
        if (Test-Path $iconCachePath) { Remove-Item $iconCachePath -Force -ErrorAction SilentlyContinue }
        Write-Log "Reiniciando el Explorador de Windows para reconstruir la caché de iconos..." -Level "STEP"
        Stop-Process -Name explorer -Force
        Start-Process explorer.exe
    }
}

function Invoke-OptionalCleanup {
    if (-not (Confirm-Action "Limpieza Opcional" "Limpia cachés de navegadores (Edge, Chrome, Firefox) y puede desactivar la hibernación para liberar espacio.")) { return }
    Write-Log "MÓDULO: Limpieza Opcional" -Level "TITLE"
    $browserCaches = @{
        "Microsoft Edge"  = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cache";
        "Google Chrome"   = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cache";
        "Mozilla Firefox" = (Get-Item "$env:APPDATA\Mozilla\Firefox\Profiles\*.default-release" -ErrorAction 0).FullName + "\cache2"
    }
    foreach ($browser in $browserCaches.Keys) {
        $path = $browserCaches[$browser]
        if (Test-Path $path) {
            if ($PSCmdlet.ShouldProcess($path, "Limpiar caché de $browser")) {
                try {
                    $processName = ""
                    if ($browser -match "Edge") { $processName = "msedge" }
                    if ($browser -match "Chrome") { $processName = "chrome" }
                    if ($browser -match "Firefox") { $processName = "firefox" }
                    Stop-Process -Name $processName -Force -ErrorAction SilentlyContinue
                    Start-Sleep -Seconds 2
                    Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
                    Write-Log "Caché de $browser limpiada con éxito." -Level "SUCCESS"
                } catch {
                    Write-Log "Fallo al limpiar la caché de $browser. Puede que no estuviera en uso." -Level "WARN"
                }
            }
        }
    }
    if (-not (powercfg /a | Select-String "La hibernación no está disponible")) {
        if ($PSCmdlet.ShouldProcess("powercfg.exe /hibernate off", "Desactivar Hibernación")) {
            powercfg.exe /hibernate off
            Write-Log "Hibernación desactivada." -Level "SUCCESS"
        }
    }
}

function Invoke-Debloat {
    if (-not (Confirm-Action "Desinstalación de Bloatware" "Elimina aplicaciones preinstaladas de Windows (UWP) y opcionalmente OneDrive.")) { return }
    Write-Log "MÓDULO: Desinstalación de Bloatware" -Level "TITLE"
    $appsToRemove = $Global:DefaultAppsToRemove
    if ($RemoveApps) { $appsToRemove += $RemoveApps }
    if ($KeepApps) { $appsToRemove = $appsToRemove | Where-Object { $appName = $_; -not ($KeepApps | Where-Object { $appName -like $_ }) } }
    $appsToRemove = $appsToRemove | Where-Object { $appName = $_; -not ($Global:EssentialApps | Where-Object { $appName -like $_ }) } | Get-Unique
    
    foreach ($pattern in $appsToRemove) {
        Get-AppxPackage -AllUsers | Where-Object { $_.Name -like "*$pattern*" } | ForEach-Object {
            if ($PSCmdlet.ShouldProcess($_.Name, "Desinstalar aplicación")) {
                try {
                    $_ | Remove-AppxPackage -AllUsers -ErrorAction Stop
                    $Global:Report.AppsRemoved.Add($_.Name) | Out-Null
                    Write-Log "Desinstalado: $($_.Name)" -Level "SUCCESS"
                } catch {
                    Write-Log "FALLO al desinstalar $($_.Name)" -Level "ERROR"
                }
            }
        }
        Get-AppxProvisionedPackage -Online | Where-Object { $_.DisplayName -like "*$pattern*" } | ForEach-Object {
            if ($PSCmdlet.ShouldProcess($_.DisplayName, "Desaprovisionar paquete")) {
                try {
                    $_ | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
                    Write-Log "Desaprovisionado: $($_.DisplayName)" -Level "SUCCESS"
                } catch {
                    Write-Log "Fallo al desaprovisionar $($_.DisplayName)" -Level "WARN"
                }
            }
        }
    }
    
    if (-not $KeepOneDrive) {
        if ($PSCmdlet.ShouldProcess("OneDrive", "Desinstalar")) {
            $oneDriveSetup = "$env:SystemRoot\SysWOW64\OneDriveSetup.exe"
            if (Test-Path $oneDriveSetup) {
                Start-Process $oneDriveSetup "/uninstall" -Wait
                $Global:Report.AppsRemoved.Add("OneDrive") | Out-Null
                Write-Log "Intento de desinstalación de OneDrive ejecutado." -Level "INFO"
            }
        }
    }
}

function Optimize-Services {
    if (-not (Confirm-Action "Optimización de Servicios" "Deshabilita tareas programadas de telemetría y el servicio SysMain (Superfetch).")) { return }
    Write-Log "MÓDULO: Optimización de Servicios y Tareas" -Level "TITLE"
    $telemetryTasks = @(
        "\Microsoft\Windows\Customer Experience Improvement Program\Consolidator",
        "\Microsoft\Windows\Customer Experience Improvement Program\KernelCeipTask",
        "\Microsoft\Windows\Customer Experience Improvement Program\UsbCeip"
    )
    foreach ($taskPath in $telemetryTasks) {
        $task = Get-ScheduledTask -TaskPath (Split-Path $taskPath -Parent) -TaskName (Split-Path $taskPath -Leaf) -ErrorAction 0
        if ($task -and $task.State -ne 'Disabled') {
            if ($PSCmdlet.ShouldProcess($taskPath, "Deshabilitar Tarea Programada")) {
                $task | Disable-ScheduledTask
                $Global:Report.TasksChanged.Add("Disabled: $taskPath") | Out-Null
                Write-Log "Tarea deshabilitada: $taskPath" -Level "SUCCESS"
            }
        }
    }
    $serviceName = "SysMain"
    $service = Get-Service -Name $serviceName -ErrorAction 0
    if ($service -and $service.StartType -ne 'Disabled') {
        if ($PSCmdlet.ShouldProcess($serviceName, "Deshabilitar Servicio")) {
            Backup-Registry -KeyPath "HKLM:\SYSTEM\CurrentControlSet\Services\$serviceName"
            Set-Service -Name $serviceName -StartupType Disabled
            $Global:Report.ServicesChanged.Add("Disabled: $serviceName") | Out-Null
            Write-Log "Servicio deshabilitado: $serviceName" -Level "SUCCESS"
        }
    }
}

function Optimize-SSD {
    if (-not (Confirm-Action "Optimización de SSD" "Verifica que la tarea de optimización de disco esté habilitada y ejecuta un ReTrim en la unidad C:")) { return }
    Write-Log "MÓDULO: Optimización de SSD" -Level "TITLE"
    $defragTask = Get-ScheduledTask -TaskName "ScheduledDefrag" -ErrorAction 0
    if ($defragTask.State -eq 'Disabled') {
        if ($PSCmdlet.ShouldProcess($defragTask.TaskPath, "Habilitar Tarea de Optimización de Unidades")) {
            $defragTask | Enable-ScheduledTask
            Write-Log "Tarea 'ScheduledDefrag' habilitada." -Level "SUCCESS"
        }
    }
    if ($PSCmdlet.ShouldProcess("Unidad C:", "Ejecutar ReTrim (Optimización de SSD)")) {
        Optimize-Volume -DriveLetter C -ReTrim -Verbose
    }
}

function Invoke-SystemTweaks {
    if (-not (Confirm-Action "Ajustes del Sistema" "Aplica mejoras de rendimiento, como activar Storage Sense y desactivar Game DVR.")) { return }
    Write-Log "MÓDULO: Ajustes del Sistema" -Level "TITLE"
    Backup-Registry -KeyPath "HKCU:\Software\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy"
    Set-RegistryValue "HKCU:\Software\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy" "01" 1 "DWord" # Enable Storage Sense
    
    if (-not $KeepGameDVR) {
        Backup-Registry -KeyPath "HKCU:\Software\Microsoft\Windows\CurrentVersion\GameDVR"
        Set-RegistryValue "HKCU:\Software\Microsoft\Windows\CurrentVersion\GameDVR" "AppCaptureEnabled" 0 "DWord"
        Backup-Registry -KeyPath "HKLM:\SOFTWARE\Microsoft\PolicyManager\default\ApplicationManagement\AllowGameDVR"
        Set-RegistryValue "HKLM:\SOFTWARE\Microsoft\PolicyManager\default\ApplicationManagement\AllowGameDVR" "value" 0 "DWord"
    }
    
    if (-not $KeepStandardPowerPlan) {
        $ultimateGuid = "e9a42b02-d5df-448d-aa00-03f14749eb61"
        if (-not (powercfg /list | Select-String $ultimateGuid)) {
            if ($PSCmdlet.ShouldProcess("Plan de Energía 'Máximo Rendimiento'", "Habilitar")) {
                powercfg -duplicatescheme $ultimateGuid
            }
        }
        if ($PSCmdlet.ShouldProcess($ultimateGuid, "Activar Plan de Energía 'Máximo Rendimiento'")) {
            powercfg /setactive $ultimateGuid
        }
    }
}

function Invoke-Privacy {
    if (-not (Confirm-Action "Ajustes de Privacidad" "Deshabilita el ID de publicidad y el servicio de telemetría principal (DiagTrack).")) { return }
    Write-Log "MÓDULO: Ajustes de Privacidad" -Level "TITLE"
    Backup-Registry -KeyPath "HKCU:\Software\Microsoft\Windows\CurrentVersion\AdvertisingInfo"
    Set-RegistryValue "HKCU:\Software\Microsoft\Windows\CurrentVersion\AdvertisingInfo" "Enabled" 0 "DWord" # Disable Advertising ID
    
    $diagTrack = Get-Service -Name "DiagTrack" -ErrorAction 0
    if ($diagTrack -and $diagTrack.StartType -ne 'Disabled') {
        if ($PSCmdlet.ShouldProcess("Servicio 'DiagTrack'", "Deshabilitar")) {
            Set-Service -Name "DiagTrack" -StartupType Disabled
            Stop-Service -Name "DiagTrack" -Force -ErrorAction SilentlyContinue
            $Global:Report.ServicesChanged.Add("Disabled: DiagTrack") | Out-Null
        }
    }
    
    if (-not $SkipTelemetryBlock) {
        $hostsPath = "$env:SystemRoot\System32\drivers\etc\hosts"
        $backupFile = Join-Path $Global:LogPath "hosts-backup-$(Get-Date -Format 'yyyyMMddHHmmss').txt"
        if ($PSCmdlet.ShouldProcess($hostsPath, "Bloquear dominios de telemetría en el archivo hosts")) {
            Copy-Item -Path $hostsPath -Destination $backupFile -Force
            $Global:Report.HostFileBackups.Add($backupFile) | Out-Null
            $newEntries = $Global:TelemetryHosts | ForEach-Object { "0.0.0.0 $_" }
            Add-Content -Path $hostsPath -Value $newEntries -Force
        }
    }
}

function Invoke-UITweaks {
    if (-not (Confirm-Action "Ajustes de UI" "Modifica el Explorador de Archivos, restaura el menú contextual clásico y ajusta la barra de tareas.")) { return }
    Write-Log "MÓDULO: Ajustes de Interfaz de Usuario (UI)" -Level "TITLE"
    $advPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
    Backup-Registry -KeyPath $advPath
    Set-RegistryValue $advPath "HideFileExt" 0 "DWord" # Show file extensions
    Set-RegistryValue $advPath "Hidden" 1 "DWord" # Show hidden files
    Set-RegistryValue $advPath "LaunchTo" 1 "DWord" # Open Explorer to 'This PC'
    Set-RegistryValue $advPath "TaskbarMn" 0 "DWord" # Align taskbar to the left
    Set-RegistryValue $advPath "TaskbarDa" 0 "DWord" # Ungroup taskbar items
    
    if (-not $KeepModernMenu) {
        $menuPath = "HKCU:\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32"
        Backup-Registry -KeyPath "HKCU:\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}"
        Set-RegistryValue $menuPath "(Default)" "" "String" # Restore classic context menu
    }
}

function Invoke-NetworkTweaks {
    if (-not (Confirm-Action "Ajustes de Red" "Limpia la caché de DNS y opcionalmente configura un DNS público (Cloudflare o Google).")) { return }
    Write-Log "MÓDULO: Ajustes de Red" -Level "TITLE"
    if ($PSCmdlet.ShouldProcess("Caché de DNS", "Limpiar (Flush)")) {
        ipconfig /flushdns
        $Global:Report.NetworkChanges.Add("Flushed DNS Cache") | Out-Null
    }
    if ($SetDNS) {
        $dnsServers = @{ Cloudflare = @("1.1.1.1", "1.0.0.1"); Google = @("8.8.8.8", "8.8.4.4") }[$SetDNS]
        $adapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }
        foreach ($adapter in $adapters) {
            if ($PSCmdlet.ShouldProcess($adapter.Name, "Establecer DNS a $SetDNS")) {
                Set-DnsClientServerAddress -InterfaceIndex $adapter.InterfaceIndex -ServerAddresses $dnsServers
                $Global:Report.NetworkChanges.Add("Set DNS on $($adapter.Name) to $SetDNS") | Out-Null
            }
        }
    }
}

function Invoke-AppUpdater {
    if (-not (Confirm-Action "Actualizador de Apps" "Usa 'winget' para buscar y aplicar actualizaciones a todas las aplicaciones instaladas.")) { return }
    Write-Log "MÓDULO: Actualizador de Aplicaciones (winget)" -Level "TITLE"
    if (-not (Get-Command winget -ErrorAction 0)) {
        Write-Log "'winget' no se encuentra o no está en el PATH. Omitiendo actualización." -Level "WARN"
        return
    }
    if ($PSCmdlet.ShouldProcess("winget", "Ejecutar 'upgrade --all'")) {
        try {
            Write-Log "Iniciando actualización masiva con winget. Esto puede tardar varios minutos..." -Level "INFO"
            & winget upgrade --all --silent --accept-source-agreements --accept-package-agreements
            Write-Log "Actualización con winget completada." -Level "SUCCESS"
        } catch {
            Write-Log "Error durante la ejecución de winget. Puede que no haya actualizaciones o haya ocurrido un problema." -Level "ERROR"
        }
    }
}

function Run-IntegrityChecks {
    if (-not (Confirm-Action "Comprobaciones de Integridad" "Ejecuta SFC /scannow y DISM /RestoreHealth para verificar y reparar archivos del sistema.")) { return }
    Write-Log "MÓDULO: Comprobaciones de Integridad del Sistema" -Level "TITLE"
    if ($PSCmdlet.ShouldProcess("sfc.exe", "Ejecutar /scannow")) {
        Write-Log "Ejecutando SFC... Esto puede tardar." -Level "INFO"
        sfc.exe /scannow | Out-Null
        if ($LASTEXITCODE -eq 0) { $Global:Report.SystemChecks.Add("SFC: OK")|Out-Null; Write-Log "SFC completado sin problemas." -Level "SUCCESS" }
        else { $Global:Report.SystemChecks.Add("SFC: Problemas encontrados")|Out-Null; Write-Log "SFC encontró problemas. Revisa el log CBS." -Level "WARN" }
    }
    if ($PSCmdlet.ShouldProcess("dism.exe", "Ejecutar /Online /Cleanup-Image /RestoreHealth")) {
        Write-Log "Ejecutando DISM... Esto puede tardar." -Level "INFO"
        dism.exe /Online /Cleanup-Image /RestoreHealth | Out-Null
        if ($? -and $LASTEXITCODE -eq 0) { $Global:Report.SystemChecks.Add("DISM: OK")|Out-Null; Write-Log "DISM completado sin problemas." -Level "SUCCESS" }
        else { $Global:Report.SystemChecks.Add("DISM: Advertencias o errores")|Out-Null; Write-Log "DISM completado con advertencias o errores." -Level "WARN" }
    }
}

function Write-Report {
    Write-Log "MÓDULO: Reporte Final" -Level "TITLE"
    $endTime = Get-Date
    $duration = New-TimeSpan -Start $Global:StartTime -End $endTime
    $finalDiskSpace = (Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'").FreeSpace
    $spaceFreedMB = if (-not $IsDryRun) { [math]::Round(($Global:InitialDiskSpace - $finalDiskSpace) / 1MB, 2) } else { [math]::Round($Global:Report.SpaceFreedBytes / 1MB, 2) }
    
    $summary = @"
======================================================================
                INFORME DE OPTIMIZACIÓN DE WINDOWS 11 (v5.3)
======================================================================
Fecha: $($endTime.ToString('yyyy-MM-dd HH:mm:ss')) | Duración: $($duration.ToString('g')) | Modo: $($Global:Report.ExecutionMode)
----------------------------------------------------------------------
Espacio Liberado (Estimado): $spaceFreedMB MB
Aplicaciones Desinstaladas: $($Global:Report.AppsRemoved.Count)
Cambios en el Registro: $($Global:Report.RegistryChanges.Count)
Backups Creados (Reg/Hosts): $($Global:Report.RegistryBackups.Count + $Global:Report.HostFileBackups.Count)
======================================================================
Log completo guardado en: $($Global:LogFile)
"@
    Write-Host $summary -ForegroundColor "Cyan"
    Add-Content -Path $Global:LogFile -Value $summary
    
    if ($JsonReport) {
        if ($PSCmdlet.ShouldProcess($JsonReport, "Exportar reporte detallado a JSON")) {
            $Global:Report | ConvertTo-Json -Depth 5 | Out-File -FilePath $JsonReport -Encoding utf8
        }
    }
}

#endregion

#region FLUJO PRINCIPAL DE EJECUCIÓN

function Main {
    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        Write-Host "------------------------------------------------------------------" -ForegroundColor "Red"
        Write-Host "ERROR: SE REQUIEREN PERMISOS DE ADMINISTRADOR." -ForegroundColor "Red"
        Write-Host "Cierra esta ventana y abre una nueva PowerShell con 'Ejecutar como administrador'." -ForegroundColor "Red"
        Write-Host "------------------------------------------------------------------" -ForegroundColor "Red"
        return
    }
    
    if ([System.Environment]::OSVersion.Version.Build -lt 22000) {
        Write-Log "Este script está diseñado para Windows 11 (Build 22000 o superior)." -Level "ERROR"
        return
    }

    Clear-Host
    Write-Host "=====================================================================" -ForegroundColor "Magenta"
    Write-Host "  Script de Optimización 'Ultimate Edition' v5.3 (Corrección Final)  " -ForegroundColor "Magenta"
    Write-Host "=====================================================================" -ForegroundColor "Magenta"
    Write-Log "Inicio de la sesión de optimización." -Level "TITLE"
    
    if ($IsDryRun) {
        Write-Log "MODO SIMULACIÓN (DryRun) ACTIVO. No se aplicarán cambios reales." -Level "WARN"
    } else {
        # Se llama a New-RestorePoint con el switch -NoRestorePoint para omitirlo por defecto.
        New-RestorePoint -NoRestorePoint
    }

    $Global:InitialDiskSpace = (Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'").FreeSpace

    $allModules = @{
        'Diagnostics'     = { Start-Diagnostics }
        'Cleanup'         = { Invoke-Cleanup }
        'OptionalCleanup' = { if ($IncludeOptionalCleanup) { Invoke-OptionalCleanup } }
        'Debloat'         = { Invoke-Debloat }
        'Services'        = { Optimize-Services }
        'SSD'             = { Optimize-SSD }
        'SystemTweaks'    = { Invoke-SystemTweaks }
        'Privacy'         = { Invoke-Privacy }
        'UITweaks'        = { Invoke-UITweaks }
        'NetworkTweaks'   = { Invoke-NetworkTweaks }
        'AppUpdater'      = { Invoke-AppUpdater }
        'Integrity'       = { Run-IntegrityChecks }
    }
    
    $modulesToRun = if ($Only) { $Only } else { $allModules.Keys }
    if ($Skip) { $modulesToRun = $modulesToRun | Where-Object { $_ -notin $Skip } }

    foreach ($moduleName in $modulesToRun) {
        if ($allModules.ContainsKey($moduleName)) {
            & $allModules[$moduleName]
        }
    }

    Write-Report
    Write-Log "Ejecución finalizada. Se recomienda reiniciar el equipo para aplicar todos los cambios." -Level "TITLE"
}

# -- Iniciar la ejecución --
try {
    Main
} catch {
    Write-Log "ERROR INESPERADO: $($_.Exception.Message)" -Level "ERROR"
    Write-Log "El script se ha detenido." -Level "ERROR"
} finally {
    Write-Log "Fin de la sesión de optimización." -Level "TITLE"
    Write-Host ""
    Read-Host "El script ha finalizado. Presiona Enter para salir."
}
