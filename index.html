<#
.SYNOPSIS
  Windows 10/11 Optimizer – SafePlus GOD MODE [Non-Interactive Final Version]

.DESCRIPTION (No Pregunta. No Falla. Solo Actúa.)
  • MODO DIOS: Cero interrupciones. Cero preguntas. Instala y actualiza todo automáticamente. Los parámetros son tu única confirmación.
  • COMPATIBILIDAD UNIVERSAL: Erradicados los errores de PowerShell 7. Todas las funciones críticas usan herramientas nativas de Windows
    (defrag.exe, dism.exe, schtasks.exe, wmic) para una estabilidad a prueba de balas.
  • OPTIMIZACIÓN DE RED Y CPU: Incluye un optimizador de TCP para redes de banda ancha y ajusta el programador de CPU para máxima respuesta.
  • ACTUALIZACIÓN TOTALMENTE AUTOMÁTICA: Instala 'PSWindowsUpdate' sin preguntar. Busca e instala actualizaciones de Windows, Drivers y
    TODOS los programas de Winget de forma silenciosa y contundente.
  • LIMPIEZA MÁS PROFUNDA: Añadida la limpieza de cachés de la Tienda, Drivers y desactivación completa de la Hibernación/Inicio Rápido.
  • TODO LO DEMÁS, PERO MÁS RÁPIDO: Todos los módulos de las versiones anteriores (Privacidad, Seguridad, Limpieza Agresiva, etc.),
    optimizados para una ejecución más veloz.
#>
[CmdletBinding(SupportsShouldProcess = $true)]
param(
  [switch]$RemoveBloatware,
  [switch]$SkipIntegrity,
  [switch]$NoUpdate,
  [switch]$DryRun,
  [switch]$AggressiveCleanup,
  [switch]$EnablePerformanceTweaks,
  [switch]$EnableUltimatePowerPlan,
  [switch]$HardenPrivacy,
  [switch]$HardenSecurity,
  [switch]$EnableProactiveMaintenance
)

#========================
# ENTORNO DE EJECUCIÓN
#========================
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
  Write-Host "[!] Ejecuta PowerShell como ADMINISTRADOR." -ForegroundColor Red; exit
}
try { Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force -ErrorAction Stop } catch {}
$ProgressPreference = 'SilentlyContinue'; $PSDefaultParameterValues['*:ErrorAction'] = 'SilentlyContinue'

Clear-Host
Write-Host "========================================================" -ForegroundColor Magenta
Write-Host "           SafePlus Optimizer - Edición GOD MODE" -ForegroundColor White
Write-Host "             >> No Pregunta. No Falla. Solo Actúa. << " -ForegroundColor Red
Write-Host "========================================================" -ForegroundColor Magenta
Start-Sleep -Seconds 3

#========================
# CONFIGURACIÓN
#========================
$BloatwareToRemove = @( "*Microsoft.Bing*", "*Microsoft.Get*", "*Microsoft.Messaging*", "*Microsoft.MicrosoftSolitaireCollection*", "*Microsoft.People*", "*Microsoft.Print3D*", 
  "*Microsoft.ScreenSketch*", "*Microsoft.WindowsAlarms*", "*Microsoft.WindowsCamera*", "*Microsoft.WindowsFeedbackHub*", "*Microsoft.WindowsMaps*", "*Microsoft.YourPhone*", 
  "*Microsoft.Zune*", "*Microsoft.Xbox*", "*king.com*", "*Microsoft.549981C3F5F10*", "*Microsoft.PowerAutomateDesktop*", "*Microsoft.Windows.Clipchamp*", 
  "*Microsoft.Todos*", "*Microsoft.Windows.Photos*", "*MicrosoftTeams*", "*Microsoft.Windows.WebExperience*" )
$ServicesToDisable = @('DiagTrack', 'dmwappushservice', 'RemoteRegistry', 'Fax', 'PhoneSvc', 'SysMain')
$TasksToDisable = @('\Microsoft\Windows\Customer Experience Improvement Program\Consolidator', '\Microsoft\Windows\Application Experience\Microsoft Compatibility Appraiser',
  '\Microsoft\Windows\DiskDiagnostic\Microsoft-Windows-DiskDiagnosticDataCollector', '\Microsoft\Windows\RetailDemo\CleanupOfflineContent', '\Microsoft\Office\Office Telemery Agent Log On')

#========================
# FUNCIONES
#========================
function Write-Log { param([string]$Message, [ValidateSet('INFO','WARN','ERROR','SUCCESS','TITLE','STEP')]$Level='INFO')
  $ts = Get-Date -Format "HH:mm:ss"; $color = @{INFO='White';WARN='Yellow';ERROR='Red';SUCCESS='Green';TITLE='Magenta';STEP='Gray'}[$Level]
  Write-Host ("[{0}] [{1}] - {2}" -f $ts,$Level,$Message) -ForegroundColor $color
}

#========================
# MÓDULOS DE ACCIÓN
#========================
function Invoke-UpdaterPreflight {
    if ($NoUpdate -or $DryRun) { return }
    Write-Log "MÓDULO PREVIO: Preparando Actualizador..." 'TITLE'
    if (Get-Module -ListAvailable -Name PSWindowsUpdate) { Write-Log "Módulo 'PSWindowsUpdate' listo." 'SUCCESS'; return }
    Write-Log "Instalando 'PSWindowsUpdate' (única vez, automático)..." 'STEP'
    try {
        if (-not (Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue)) { Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force }
        Install-Module -Name PSWindowsUpdate -Force -SkipPublisherCheck -Scope AllUsers
        if (Get-Module -ListAvailable -Name PSWindowsUpdate) { Write-Log "Módulo 'PSWindowsUpdate' instalado." 'SUCCESS' } else { throw "Fallo de instalación." }
    } catch { Write-Log "FALLO CRÍTICO: No se pudo instalar 'PSWindowsUpdate'." 'ERROR' }
}

function Invoke-SystemDiagnostics {
  Write-Log "MÓDULO: Diagnóstico y Respaldo" 'TITLE'
  $os = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object Caption, Version
  $disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'"
  Write-Log "SO: $($os.Caption) | Disco C: $([math]::Round($disk.FreeSpace/1GB,2)) GB Libres" 'INFO'
  if(-not $DryRun){ 
    Write-Log "Creando Punto de Restauración..." 'STEP'
    try { (Get-WmiObject -list -namespace root\default -class SystemRestore).CreateRestorePoint("SafePlus GOD MODE Backup", 0, 100) | Out-Null } catch {}
  }
}

function Invoke-DeepClean {
  Write-Log "MÓDULO: Limpieza Profunda del Sistema" 'TITLE'
  if ($DryRun) { return }
  $paths = @("$env:SystemRoot\Temp\*","$env:SystemRoot\SoftwareDistribution\Download\*","$env:ProgramData\Microsoft\Windows\WER\*","$env:SystemRoot\Prefetch\*.pf",
    "$env:LOCALAPPDATA\NVIDIA\GLCache\*","$env:SystemRoot\Minidump\*.dmp","$env:LOCALAPPDATA\Packages\Microsoft.WindowsStore_8wekyb3d8bbwe\LocalCache\*")
  Get-ChildItem 'C:\Users' -Directory | ? {$_.Name -notin @('Default','Public')} | % { $paths += "$($_.FullName)\AppData\Local\Temp\*" }
  $paths | ForEach-Object { Remove-Item $_ -Recurse -Force }
  Clear-RecycleBin -Force; ipconfig /flushdns | Out-Null
  Write-Log "Limpieza de sistema completada." 'SUCCESS'
}

function Invoke-AggressiveClean {
  if (!$AggressiveCleanup -or $DryRun) { return }
  Write-Log "MÓDULO: Limpieza Agresiva" 'TITLE'
  vssadmin delete shadows /all /quiet | Out-Null
  try {
      $installer = New-Object -ComObject WindowsInstaller.Installer; $allProducts = $installer.ProductsEx("","","7")
      $validMSIs = [System.Collections.Generic.HashSet[string]]@(); $allProducts | % { $path = $_.InstallProperty("LocalPackage"); if($path){[void]$validMSIs.Add([System.IO.Path]::GetFileName($path))} }
      Get-ChildItem "C:\Windows\Installer" -Filter "*.msi" -Recurse -Force | ? { !$validMSIs.Contains($_.Name) } | Remove-Item -Force
  } catch {}
  sfc.exe /purgecache | Out-Null; Stop-Service Spooler -Force; Remove-Item "$env:SystemRoot\System32\spool\PRINTERS\*" -Recurse -Force; Start-Service Spooler
  dism.exe /Online /Cleanup-Image /StartComponentCleanup /ResetBase | Out-Null
  Write-Log "Limpieza agresiva completada." 'SUCCESS'
}

function Invoke-Debloat {
  if (!$RemoveBloatware -or $DryRun) { return }
  Write-Log "MÓDULO: Eliminación de Bloatware" 'TITLE'
  try {
      if($PSVersionTable.PSEdition -eq 'Core') { Import-Module Appx -UseWindowsPowerShell }
      $BloatwareToRemove.ForEach({ Get-AppxPackage -Name $_ -AllUsers | Remove-AppxPackage -AllUsers })
  } catch { Write-Log "No se pudo cargar el módulo Appx. Se omite la eliminación de bloatware." 'WARN' }
  Write-Log "Eliminación de bloatware completada." 'SUCCESS'
}

function Invoke-SystemTuning {
  Write-Log "MÓDULO: Ajuste Fino del Sistema y UI" 'TITLE'
  if ($DryRun) { return }
  $ServicesToDisable.ForEach({ Set-Service -Name $_ -StartupType Disabled })
  $TasksToDisable.ForEach({ schtasks /Change /TN $_ /DISABLE | Out-Null })
  if ($EnablePerformanceTweaks) {
    # Tweak de UI
    Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\VisualEffects" "VisualFXSetting" 3
    Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Serialize" "StartupDelayInMSec" 0 -Force
    New-Item "HKCU:\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" -Force | Set-ItemProperty -Name "(Default)" -Value ""
    # Tweak de CPU
    Set-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\PriorityControl" "Win32PrioritySeparation" 26 -Type DWord
    # Tweak de NTFS
    fsutil behavior set disablelastaccess 1 | Out-Null
    # TCP Optimizer
    netsh int tcp set global autotuninglevel=normal
    netsh int tcp set global congestionprovider=ctcp
    netsh int tcp set global ecncapability=enabled
  }
  Write-Log "Ajuste de Sistema completado." 'SUCCESS'
}

function Invoke-PrivacyAndSecurity {
    if (!$HardenPrivacy -and !$HardenSecurity -or $DryRun) { return }
    Write-Log "MÓDULO: Blindaje de Privacidad y Seguridad" 'TITLE'
    if ($HardenPrivacy) { Set-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection" "AllowTelemetry" 0 -Type DWord }
    if ($HardenSecurity) {
        dism.exe /Online /Disable-Feature /FeatureName:SMB1Protocol /NoRestart | Out-Null
        Set-MpPreference -ControlledFolderAccessEnable Enabled
        dism.exe /Online /Disable-Feature /FeatureName:PowerShell-V2 /NoRestart | Out-Null
    }
    Write-Log "Blindaje completado." 'SUCCESS'
}

function Invoke-DriveMaintenance {
  if ($DryRun) { return }
  Write-Log "MÓDULO: Mantenimiento de Discos y Energía" 'TITLE'
  powercfg /h off | Out-Null; Set-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Power" "HiberbootEnabled" 0 -Type DWord
  Get-CimInstance -ClassName Win32_DiskDrive | ForEach-Object {
    $driveLetter = (Get-Partition -DiskNumber $_.DiskNumber | Where-Object { $_.DriveLetter } | Select-Object -First 1).DriveLetter
    if($driveLetter) {
        $mediaType = (Get-PhysicalDisk -DeviceId $_.DeviceId).MediaType
        if($mediaType -eq 'SSD') { defrag.exe "$($driveLetter):" /L | Out-Null }
        else { defrag.exe "$($driveLetter):" /O | Out-Null }
    }
  }
  if ($EnableProactiveMaintenance) { Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy" "01" 1 -Type DWord }
  if ($EnableUltimatePowerPlan) { $guid = "e9a42b02-d5df-448d-aa00-03f14749eb61"; if (-not (powercfg /l | Select-String -Pattern $guid)) { powercfg -duplicatescheme 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c }; powercfg /s $guid }
  Write-Log "Mantenimiento de discos completado." 'SUCCESS'
}

function Invoke-SystemUpdates {
  if ($NoUpdate -or $DryRun) { return }
  Write-Log "MÓDULO: Actualización Total del Sistema" 'TITLE'
  if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) { Write-Log "PSWindowsUpdate no disponible." 'WARN'; return }
  Import-Module PSWindowsUpdate -Force
  Get-WindowsUpdate -AcceptAll -Install -Verbose | Out-Null
  Get-WindowsUpdate -Driver -AcceptAll -Install -Verbose | Out-Null
  if (Get-Command winget) { winget source update; winget upgrade --all --accept-source-agreements --accept-package-agreements --disable-interactivity }
  Write-Log "Actualización del sistema completada." 'SUCCESS'
}

#========================
# EJECUCIÓN SECUENCIAL
#========================
$startTime = Get-Date
try {
    Invoke-UpdaterPreflight
    Invoke-SystemDiagnostics
    Invoke-DeepClean
    Invoke-AggressiveClean
    Invoke-Debloat
    Invoke-SystemTuning
    Invoke-PrivacyAndSecurity
    Invoke-DriveMaintenance
    Invoke-SystemUpdates
    if (-not $SkipIntegrity -and -not $DryRun) { Write-Log "MÓDULO: Integridad del Sistema" 'TITLE'; sfc.exe /scannow | Out-Null; dism.exe /Online /Cleanup-Image /RestoreHealth | Out-Null }
}
finally {
    $duration = (Get-Date) - $startTime
    Write-Log "================= FIN DEL PROCESO =================" 'TITLE'
    Write-Log ("Duración Total: {0:N2} segundos" -f $duration.TotalSeconds) 'INFO'
    Write-Host "Proceso completado. Se recomienda REINICIAR el equipo AHORA." -ForegroundColor Green
}
